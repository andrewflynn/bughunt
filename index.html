<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BugHunt - Web Edition</title>
    <style>
        body {
            background-color: #222;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        h1 { margin: 10px 0; font-size: 32px; text-shadow: 2px 2px #000; }
        
        #gameContainer {
            position: relative;
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            /* Dynamic upscaling keeping 4:3 ratio */
            width: 90vw;
            max-width: 960px;
            aspect-ratio: 4 / 3;
        }
        
        canvas {
            display: block;
            background-color: #000;
            width: 100%;
            height: 100%;
            /* Keeps retro pixel look sharp */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            margin-top: 15px;
            text-align: center;
            width: 90vw;
            max-width: 960px;
        }
        .controls {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            margin-top: 10px;
        }
        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            color: #333;
            display: inline-block;
            font-size: .85em;
            font-weight: 700;
            padding: 2px 6px;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: yellow;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 3px 3px #000;
            display: none;
            text-align: center;
            pointer-events: none;
            width: 100%;
        }
    </style>
</head>
<body>

    <h1>BUGHUNT</h1>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        <div id="message"></div>
    </div>

    <div id="ui">
        <div class="controls">
            <strong>Controls:</strong> <kbd>NumPad</kbd> or <kbd>Arrow Keys</kbd> (Home/End for diagonals).<br>
            Goal: Navigate from Top-Left to Bottom-Right.<br>
            Press <kbd>Space</kbd> or <kbd>Enter</kbd> to Start/Restart.
        </div>
        <div style="margin-top: 15px; font-size: 18px;">
            <label for="speedRange">Speed:</label>
            <input type="range" id="speedRange" min="1" max="15" value="5">
            <span id="speedDisplay">5</span>
        </div>
    </div>

<script>
/**
 * BUGHUNT - Web Port
 * Original Logic adapted from QuickBASIC.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const msgEl = document.getElementById('message');
const speedRange = document.getElementById('speedRange');
const speedDisplay = document.getElementById('speedDisplay');

// Offscreen canvas for collision detection
const wallCanvas = document.createElement('canvas');
wallCanvas.width = 640;
wallCanvas.height = 480;
const wallCtx = wallCanvas.getContext('2d');

// Game State
let gameState = 'MENU'; 
let gameSpeed = 5; 
let frameCount = 0;

// The Bug
const bug = {
    x: 28,
    y: 28,
    width: 24,
    height: 20,
    dx: 0,
    dy: 0,
    color1: '#00AA00', 
    color2: '#5555FF', 
    color3: '#AA5500', 
};

// Maze Data (Split for safety)
const MAZE_STR = 
    "BH200 BL10 D50 L40 D40 R60 U90 L20 BD70 BL90 D80 R70 D20 L90 U100 R20 BR170 BD20 D60 L40 D80 " +
    "L60 D60 R80 U40 R60 U40 L20 U60 R40 U60 L60 BU60 R120 D80 R60 U100 L180 D20 BD200 BL170 D80 " +
    "L20 U80 R20 BD120 BR40 D80 R100 U60 R80 U40 R20 U20 L40 D40 L160 BU180 BR240 D180 R100 U160 " +
    "L60 U20 L40 BU40 BR120 U90 R20 D20 R100 U20 R20 D40 R20 D40 L60 D60 L40 U50 L60 BR60 BD120 " +
    "R60 D80 L20 U40 L40 U40 BD120 BL100 D60 R120 U40 L20 U20 L100 BL370 BU370 BR230 U30 R30 D30 " +
    "L30 BR20 BD100 R40 D30 L40 U30";

function init() {
    // 1. Prepare Collision Map
    drawMazeToCanvas(wallCtx, MAZE_STR);
    
    // 2. Initial Draw
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0, 640, 480);
    drawMazeToCanvas(ctx, MAZE_STR);
    resetBug();
    
    // Draw bug with a valid timestamp (Date.now is safer fallback)
    drawBug(performance ? performance.now() : Date.now());
    
    showMessage("PRESS ENTER TO START");
    
    // 3. Setup Inputs
    window.addEventListener('keydown', handleInput);
    speedRange.addEventListener('input', function(e) {
        updateSpeed(e.target.value);
    });
}

function resetBug() {
    bug.x = 28;
    bug.y = 28;
    bug.dx = 0;
    bug.dy = 0;
}

function updateSpeed(val) {
    gameSpeed = parseInt(val, 10);
    speedDisplay.innerText = val;
}

// --- Maze Parsing ---
function drawMazeToCanvas(context, cmdStr) {
    context.fillStyle = "#000";
    context.fillRect(0,0, 640, 480);
    context.strokeStyle = "#00AA00"; 
    context.lineWidth = 2;
    context.beginPath();

    let x = 320; 
    let y = 240;
    context.moveTo(x, y);

    const regex = /([B]?)([UDLRHEFG])(\d+)/g;
    let match;

    while ((match = regex.exec(cmdStr)) !== null) {
        const blind = match[1] === "B";
        const dir = match[2];
        const dist = parseInt(match[3], 10);

        let dx = 0, dy = 0;
        switch(dir) {
            case 'U': dy = -1; break;
            case 'D': dy = 1; break;
            case 'L': dx = -1; break;
            case 'R': dx = 1; break;
            case 'E': dx = 1; dy = -1; break; 
            case 'F': dx = 1; dy = 1; break;  
            case 'G': dx = -1; dy = 1; break; 
            case 'H': dx = -1; dy = -1; break;
        }

        const tx = x + (dx * dist);
        const ty = y + (dy * dist);

        if (blind) {
            context.moveTo(tx, ty);
        } else {
            context.lineTo(tx, ty);
        }
        x = tx; y = ty;
    }
    context.stroke();
}

// --- Smooth Bug Animation ---
function drawBug(timestamp) {
    // Safety: Ensure timestamp is a number
    if (typeof timestamp !== 'number') timestamp = 0;

    const { x, y, width, height } = bug;
    ctx.save();
    ctx.translate(x, y);

    // Legs: Calculate sine wave for "rowing" motion
    // speedMultiplier controls leg flap speed (independent of movement)
    // swing controls how far pixels move
    const speedMultiplier = 0.015; 
    const swing = 5; 
    const phaseL = Math.sin(timestamp * speedMultiplier);
    const phaseR = Math.sin(timestamp * speedMultiplier + Math.PI); // Opposite phase

    ctx.strokeStyle = bug.color1;
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    // Left Legs
    ctx.moveTo(0, 5);  ctx.lineTo(-6, 2 + phaseL * swing);
    ctx.moveTo(0, 10); ctx.lineTo(-8, 10 - phaseL * swing);
    ctx.moveTo(0, 15); ctx.lineTo(-6, 18 + phaseL * swing);

    // Right Legs
    ctx.moveTo(width, 5);  ctx.lineTo(width+6, 2 + phaseR * swing);
    ctx.moveTo(width, 10); ctx.lineTo(width+8, 10 - phaseR * swing);
    ctx.moveTo(width, 15); ctx.lineTo(width+6, 18 + phaseR * swing);
    
    ctx.stroke();

    // Body
    ctx.fillStyle = bug.color1;
    ctx.fillRect(0, 0, width, height);

    // Stripes
    ctx.fillStyle = bug.color2;
    ctx.fillRect(4, 0, 2, height);
    ctx.fillRect(10, 0, 2, height);
    ctx.fillRect(16, 0, 2, height);

    // Eyes
    ctx.fillStyle = bug.color3;
    ctx.fillRect(width-4, 2, 4, 4);
    ctx.fillRect(width-4, height-6, 4, 4);

    // Mandibles
    ctx.strokeStyle = bug.color1;
    ctx.beginPath();
    ctx.moveTo(width, 8); ctx.lineTo(width+5, 10); ctx.lineTo(width, 12);
    ctx.stroke();

    ctx.restore();
}

// --- Game Loop ---
function startGame() {
    if (gameState === 'PLAYING') return;
    gameState = 'PLAYING';
    resetBug();
    bug.dx = 1;
    bug.dy = 0;
    msgEl.style.display = 'none';
    requestAnimationFrame(gameLoop);
}

function gameLoop(timestamp) {
    if (gameState !== 'PLAYING') return;

    // Movement Logic (Throttled by Speed Slider)
    // 1 (Fastest input) -> update every frame
    // 15 (Slowest input) -> update every 10 frames
    // Inverted logic: Speed 1 (Slow) ... Speed 15 (Fast)? 
    // Original prompt: "To set speed... type a number between 1 and 15". 
    // Usually higher = faster. Let's make 15 fast, 1 slow.
    const updateFreq = Math.max(1, Math.floor((16 - gameSpeed) / 2)); 
    
    frameCount++;
    if (frameCount % updateFreq === 0) {
        update();
    }

    // Drawing Logic (Always run at full FPS for smooth animation)
    draw(timestamp);

    requestAnimationFrame(gameLoop);
}

function update() {
    const nextX = bug.x + bug.dx;
    const nextY = bug.y + bug.dy;

    // Screen Bounds
    if (nextX < 0 || nextX > 640 - bug.width || nextY < 0 || nextY > 480 - bug.height) {
        gameOver();
        return;
    }

    // Wall Collision
    if (checkCollision(nextX, nextY)) {
        gameOver();
        return;
    }

    bug.x = nextX;
    bug.y = nextY;

    // Victory Zone
    if (bug.x >= 600 && bug.y >= 400 && bug.y <= 470) {
        victory();
    }
}

function checkCollision(x, y) {
    // Check 5 points on the bug against the green wall color
    const points = [
        {x: x, y: y}, 
        {x: x + bug.width, y: y}, 
        {x: x, y: y + bug.height}, 
        {x: x + bug.width, y: y + bug.height}, 
        {x: x + bug.width/2, y: y + bug.height/2}
    ];

    for (let p of points) {
        // Read from offscreen collision map
        const pixel = wallCtx.getImageData(p.x, p.y, 1, 1).data;
        // If Green channel > 100, it's a wall
        if (pixel[1] > 100) {
            return true;
        }
    }
    return false;
}

function draw(timestamp) {
    // Clear and draw background maze
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, 640, 480);
    ctx.drawImage(wallCanvas, 0, 0);
    
    // Draw animated bug
    drawBug(timestamp);
}

function gameOver() {
    gameState = 'GAMEOVER';
    showMessage("GAME OVER!<br><span style='font-size:24px'>Press Enter to Try Again</span>");
}

function victory() {
    gameState = 'VICTORY';
    let hue = 0;
    const winLoop = () => {
        if (gameState !== 'VICTORY') return;
        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.font = "bold 56px Courier New";
        ctx.fillText("VICTORY!", 190, 240);
        hue = (hue + 10) % 360;
        requestAnimationFrame(winLoop);
    }
    winLoop();
    showMessage("CONGRATULATIONS!<br><span style='font-size:24px'>You did it!</span>");
}

function showMessage(html) {
    msgEl.innerHTML = html;
    msgEl.style.display = 'block';
}

function handleInput(e) {
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }

    if (gameState !== 'PLAYING') {
        if (e.key === 'Enter' || e.key === ' ') {
            if (gameState === 'VICTORY' || gameState === 'GAMEOVER') {
                resetBug();
                // Redraw initial state so bug resets visually immediately
                drawBug(performance.now());
            }
            startGame();
        }
        return;
    }
    
    switch(e.key) {
        case 'ArrowUp': case '8': case 'w':
            bug.dx = 0; bug.dy = -1; break;
        case 'ArrowDown': case '2': case 's':
            bug.dx = 0; bug.dy = 1; break;
        case 'ArrowLeft': case '4': case 'a':
            bug.dx = -1; bug.dy = 0; break;
        case 'ArrowRight': case '6': case 'd':
            bug.dx = 1; bug.dy = 0; break;
        case 'Home': case '7': 
            bug.dx = -1; bug.dy = -1; break;
        case 'PageUp': case '9': 
            bug.dx = 1; bug.dy = -1; break;
        case 'End': case '1': 
            bug.dx = -1; bug.dy = 1; break;
        case 'PageDown': case '3': 
            bug.dx = 1; bug.dy = 1; break;
    }
}

// Start
init();

</script>
</body>
</html>
