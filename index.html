<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BugHunt - Web Edition</title>
    <style>
        body {
            background-color: #222;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        h1 { margin: 10px 0; font-size: 32px; text-shadow: 2px 2px #000; }
        
        #gameContainer {
            position: relative;
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            /* Upscale styling: scales dynamically up to a large size */
            width: 90vw;
            max-width: 960px; /* 1.5x original resolution */
            aspect-ratio: 4 / 3;
        }
        
        canvas {
            display: block;
            background-color: #000;
            width: 100%;
            height: 100%;
            /* Keeps the retro pixel-art crispness when scaled up */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            margin-top: 15px;
            text-align: center;
            width: 90vw;
            max-width: 960px;
        }
        .controls {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            margin-top: 10px;
        }
        kbd {
            background-color: #eee;
            border-radius: 3px;
            border: 1px solid #b4b4b4;
            box-shadow: 0 1px 1px rgba(0,0,0,.2), 0 2px 0 0 rgba(255,255,255,.7) inset;
            color: #333;
            display: inline-block;
            font-size: .85em;
            font-weight: 700;
            line-height: 1;
            padding: 2px 6px;
            white-space: nowrap;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: yellow;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 3px 3px #000;
            display: none;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <h1>BUGHUNT</h1>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="640" height="480"></canvas>
        <div id="message"></div>
    </div>

    <div id="ui">
        <div class="controls">
            <strong>Controls:</strong> Use <kbd>NumPad</kbd> or <kbd>Arrow Keys</kbd> (Home/End/PgUp/PgDn for diagonals).<br>
            Goal: Navigate from Top-Left to Bottom-Right.<br>
            Press <kbd>Space</kbd> or <kbd>Enter</kbd> to Start/Restart.
        </div>
        <div style="margin-top: 15px; font-size: 18px;">
            <label for="speedRange">Speed:</label>
            <input type="range" id="speedRange" min="1" max="15" value="5">
            <span id="speedDisplay">5</span>
        </div>
    </div>

<script>
/**
 * BUGHUNT - Web Port
 * Original Logic adapted from QuickBASIC.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const msgEl = document.getElementById('message');
const speedRange = document.getElementById('speedRange');
const speedDisplay = document.getElementById('speedDisplay');

// Collision Canvas (Offscreen)
const wallCanvas = document.createElement('canvas');
wallCanvas.width = 640;
wallCanvas.height = 480;
const wallCtx = wallCanvas.getContext('2d');

// Game State
let gameState = 'MENU'; 
let gameSpeed = 5; 
let frameCount = 0;

// The Bug
const bug = {
    x: 28,
    y: 28,
    width: 24,
    height: 20,
    dx: 0,
    dy: 0,
    color1: '#00AA00', 
    color2: '#5555FF', 
    color3: '#AA5500', 
};

// The Maze String
const MAZE_STR = "BH200 BL10 D50 L40 D40 R60 U90 L20 BD70 BL90 D80 R70 D20 L90 U100 R20 BR170 BD20 D60 L40 D80 L60 D60 R80 U40 R60 U40 L20 U60 R40 U60 L60 BU60 R120 D80 R60 U100 L180 D20 BD200 BL170 D80 L20 U80 R20 BD120 BR40 D80 R100 U60 R80 U40 R20 U20 L40 D40 L160 BU180 BR240 D180 R100 U160 L60 U20 L40 BU40 BR120 U90 R20 D20 R100 U20 R20 D40 R20 D40 L60 D60 L40 U50 L60 BR60 BD120 R60 D80 L20 U40 L40 U40 BD120 BL100 D60 R120 U40 L20 U20 L100 BL370 BU370 BR230 U30 R30 D30 L30 BR20 BD100 R40 D30 L40 U30";

function init() {
    drawMazeToCanvas(wallCtx, MAZE_STR);
    
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0, 640, 480);
    drawMazeToCanvas(ctx, MAZE_STR);
    resetBug();
    drawBug(performance.now());
    showMessage("PRESS ENTER TO START");
    
    // Attach event listeners via JS so they work in all environments
    window.addEventListener('keydown', handleInput);
    speedRange.addEventListener('input', function(e) {
        updateSpeed(e.target.value);
    });
}

function resetBug() {
    bug.x = 28;
    bug.y = 28;
    bug.dx = 0;
    bug.dy = 0;
}

function updateSpeed(val) {
    gameSpeed = parseInt(val, 10);
    speedDisplay.innerText = val;
}

// --- Maze Parsing ---
function drawMazeToCanvas(context, cmdStr) {
    context.fillStyle = "#000";
    context.fillRect(0,0, 640, 480);
    
    context.strokeStyle = "#00AA00"; 
    context.lineWidth = 2;
    context.beginPath();

    let x = 320; 
    let y = 240;
    context.moveTo(x, y);

    const regex = /([B]?)([UDLRHEFG])(\d+)/g;
    let match;

    while ((match = regex.exec(cmdStr)) !== null) {
        const blind = match[1] === "B";
        const dir = match[2];
        const dist = parseInt(match[3], 10);

        let dx = 0, dy = 0;

        switch(dir) {
            case 'U': dy = -1; break;
            case 'D': dy = 1; break;
            case 'L': dx = -1; break;
            case 'R': dx = 1; break;
            case 'E': dx = 1; dy = -1; break; 
            case 'F': dx = 1; dy = 1; break;  
            case 'G': dx = -1; dy = 1; break; 
            case 'H': dx = -1; dy = -1; break;
        }

        const tx = x + (dx * dist);
        const ty = y + (dy * dist);

        if (blind) {
            context.moveTo(tx, ty);
        } else {
            context.lineTo(tx, ty);
        }

        x = tx; y = ty;
    }
    
    context.stroke();
}

// --- Drawing the Bug (Smoothly Animated) ---
function drawBug(timestamp) {
    const { x, y, width, height } = bug;

    ctx.save();
    ctx.translate(x, y);

    // Legs
    ctx.strokeStyle = bug.color1;
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    // Calculate a smooth sine wave based on time for scurrying
    const speedMultiplier = 0.025; // Controls how fast the legs flap
    const phase1 = Math.sin(timestamp * speedMultiplier);
    const phase2 = Math.sin(timestamp * speedMultiplier + Math.PI); // Opposite phase
    const swing = 4; // How far the legs swing in pixels

    // Left legs 
    ctx.moveTo(0, 5); ctx.lineTo(-6, 0 + phase1 * swing);   // Top
    ctx.moveTo(0, 10); ctx.lineTo(-8, 10 + phase2 * swing); // Middle
    ctx.moveTo(0, 15); ctx.lineTo(-6, 20 + phase1 * swing); // Bottom

    // Right legs (mirrored and alternating to look like walking)
    ctx.moveTo(width, 5); ctx.lineTo(width+6, 0 + phase2 * swing);   // Top
    ctx.moveTo(width, 10); ctx.lineTo(width+8, 10 + phase1 * swing); // Middle
    ctx.moveTo(width, 15); ctx.lineTo(width+6, 20 + phase2 * swing); // Bottom

    ctx.stroke();

    // Body
    ctx.fillStyle = bug.color1;
    ctx.fillRect(0, 0, width, height);

    // Stripes
    ctx.fillStyle = bug.color2;
    ctx.fillRect(4, 0, 2, height);
    ctx.fillRect(10, 0, 2, height);
    ctx.fillRect(16, 0, 2, height);

    // Eyes
    ctx.fillStyle = bug.color3;
    ctx.fillRect(width-4, 2, 4, 4);
    ctx.fillRect(width-4, height-6, 4, 4);

    // Mandibles
    ctx.strokeStyle = bug.color1;
    ctx.beginPath();
    ctx.moveTo(width, 8); ctx.lineTo(width+5, 10); ctx.lineTo(width, 12);
    ctx.stroke();

    ctx.restore();
}

// --- Game Loop ---
function startGame() {
    if (gameState === 'PLAYING') return;
    gameState = 'PLAYING';
    resetBug();
    bug.dx = 1;
    bug.dy = 0;
    msgEl.style.display = 'none';
    requestAnimationFrame(gameLoop);
}

function gameLoop(timestamp) {
    if (gameState !== 'PLAYING') return;

    // The update frequency controls how often the bug actually MOVES forward
    // Lower speed means it skips more logic frames, but we will still redraw
    // the leg animation smoothly every single browser frame.
    const updateFreq = Math.max(1, Math.floor((16 - gameSpeed) / 2)); 
    
    frameCount++;
    if (frameCount % updateFreq === 0) {
        update();
    }

    // Always draw at full FPS for smooth leg animation
    draw(timestamp);

    // Continue the loop
    if (gameState === 'PLAYING') {
        requestAnimationFrame(gameLoop);
    }
}

function update() {
    const nextX = bug.x + bug.dx;
    const nextY = bug.y + bug.
